from __future__ import annotations
import subprocess
import os
import sys
import re
import time
import tempfile
import shutil
import threading
import logging
from datetime import datetime
from typing import TYPE_CHECKING, List, Optional
from deluge.parsers import ParserFactory
from deluge.core.logger import setup_logger, mute_logger, unmute_logger
from deluge.core.models import ScanResult
from deluge.core.export import ExportManager

if TYPE_CHECKING:
    from deluge.interface.formatter import NmapFormatter

logger = logging.getLogger(__name__)


class ScanEngine:
    def __init__(self, verbose: bool = False):
        self.logger = setup_logger(verbose)
        self.verbose = verbose

    def run_nmap(
        self,
        nmap_args: List[str],
        output_file: Optional[str] = None,
        quiet: bool = False,
    ) -> Optional[ScanResult]:
        """Runs an nmap scan and processes the output with progress tracking."""
        from rich.progress import (
            Progress,
            SpinnerColumn,
            TextColumn,
            BarColumn,
            TaskProgressColumn,
            TimeElapsedColumn,
        )

        with tempfile.NamedTemporaryFile(delete=False, suffix=".xml") as tmp:
            xml_path = tmp.name

        # Add stats flag for progress tracking
        enhanced_args = nmap_args + ["--stats-every", "2s"]
        cmd = ["nmap"] + enhanced_args + ["-oX", xml_path]

        try:
            if not quiet:
                self.logger.info("Starting nmap scan...")
            if self.verbose:
                self.logger.debug(f"Command: {' '.join(cmd)}")

            # Use Popen for real-time progress tracking
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE if quiet else None,
                stderr=subprocess.PIPE,
                text=True,
                bufsize=1,
                universal_newlines=True,
            )

            # Progress bar setup - only show when not quiet
            if not quiet:
                with Progress(
                    SpinnerColumn(),
                    TextColumn("[progress.description]{task.description}"),
                    BarColumn(),
                    TaskProgressColumn(),
                    TimeElapsedColumn(),
                    transient=True,
                ) as progress:
                    task = progress.add_task("[#89dceb]Scanning...", total=100)

                    # Read stderr for progress updates
                    while True:
                        line = process.stderr.readline()
                        if not line and process.poll() is not None:
                            break

                        if line:
                            # Parse progress info: "Stats: 0:00:15 elapsed; 0 hosts completed (1 total), 0.00% done"
                            # Or: "About 25.00% done; ETC: 14:32 (0:00:45 remaining)"
                            if "done" in line:
                                match = re.search(r"(\d+\.\d+)%\s+done", line)
                                if match:
                                    percentage = float(match.group(1))
                                    progress.update(task, completed=percentage)

                            # In verbose mode, show everything.
                            if self.verbose:
                                sys.stderr.write(line)
                                sys.stderr.flush()

                returncode = process.wait()
            else:
                # When quiet, just consume stderr without showing progress bar
                while True:
                    line = process.stderr.readline()
                    if not line and process.poll() is not None:
                        break

                    # In verbose mode, show everything even in quiet mode
                    if line and self.verbose:
                        sys.stderr.write(line)
                        sys.stderr.flush()

                # Consume remaining stdout to avoid deadlocks
                if process.stdout:
                    process.stdout.read()

                returncode = process.wait()

            if returncode != 0:
                self.logger.error(f"nmap exited with code {returncode}")
                return None

            if not os.path.exists(xml_path) or os.path.getsize(xml_path) == 0:
                self.logger.error("No XML output generated by nmap.")
                return None

            if output_file:
                shutil.copy(xml_path, output_file)
                self.logger.info(f"Raw XML output saved to: {output_file}")

            return self.parse_file(xml_path)

        except FileNotFoundError:
            if not quiet:
                self.logger.error(
                    "nmap command not found. Please ensure nmap is installed and in your PATH."
                )
            return None
        except Exception as e:
            self.logger.exception(f"An unexpected error occurred: {str(e)}")
            return None
        finally:
            if os.path.exists(xml_path):
                os.remove(xml_path)

    def parse_file(self, file_path: str) -> Optional[ScanResult]:
        """Parses an existing scan file (XML or stdout)."""
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                content = f.read()

            parser = ParserFactory.get_parser(content)
            if not parser:
                self.logger.error(f"Could not detect format for file: {file_path}")
                return None

            self.logger.debug(f"Using parser: {parser.__class__.__name__}")
            result = parser.parse(content)

            if self.verbose:
                self.logger.debug(f"Parsed {len(result.hosts)} hosts.")

            return result
        except Exception as e:
            self.logger.error(f"Error processing file: {str(e)}")
            if self.verbose:
                self.logger.exception(e)
            return None

    def parse_content(self, content: str) -> Optional[ScanResult]:
        """Parses scan content directly from a string."""
        try:
            parser = ParserFactory.get_parser(content)
            if not parser:
                self.logger.error("Could not detect format for provided content.")
                return None

            self.logger.debug(f"Using parser: {parser.__class__.__name__}")
            result = parser.parse(content)

            if self.verbose:
                self.logger.debug(f"Parsed {len(result.hosts)} hosts.")

            return result
        except Exception as e:
            self.logger.error(f"Error processing content: {str(e)}")
            if self.verbose:
                self.logger.exception(e)
            return None

    def run_interactive_scan(
        self,
        nmap_args: List[str],
        formatter: "NmapFormatter",
        export_dir: Optional[str] = None,
        num_workers: int = 3,
    ) -> Optional[ScanResult]:
        """Reads RustScan output from stdin line-by-line and captures comprehensive nmap output."""
        # Validate num_workers
        if num_workers < 1:
            self.logger.warning(
                f"Invalid num_workers={num_workers}, using default of 3"
            )
            num_workers = 3
        elif num_workers > 50:
            self.logger.warning(
                f"num_workers={num_workers} is very high, performance may degrade"
            )

        from collections import defaultdict
        import queue
        from rich.progress import (
            Progress,
            SpinnerColumn,
            TextColumn,
            BarColumn,
            TaskProgressColumn,
            TimeElapsedColumn,
        )
        from rich.live import Live

        # Initialize export manager if requested
        export_manager = None
        if export_dir:
            try:
                export_manager = ExportManager(export_dir)
                logger.info(f"Export directory: {export_manager.export_dir}")
            except Exception as e:
                logger.error(f"Failed to initialize export manager: {e}")

        discovered_ports = defaultdict(list)
        scan_statuses = {}  # target -> status
        all_stdin_lines = []

        # Queue and threading for iterative scanning
        scan_queue = queue.Queue()
        final_result = ScanResult(
            nmap_version="Interactive",
            args=" ".join(nmap_args),
            hosts=[],
            start_time=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        )
        ui_lock = threading.Lock()
        stdin_done = threading.Event()

        from rich.console import Console

        console = Console()
        console.print(
            "[dim]Entering interactive scan mode. Waiting for RustScan output...[/dim]"
        )

        # Mute logger to prevent UI flickering during Live display
        mute_logger()

        # Progress bar for the bottom of the Live display
        progress = Progress(
            SpinnerColumn(spinner_name="line"),
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            TaskProgressColumn(),
            TimeElapsedColumn(),
            console=formatter.console,
        )

        # Define tasks
        discovery_task = progress.add_task("[#cba6f7]Ports Discovered", total=None)
        scan_task = progress.add_task("[#89dceb]Nmap Scans", total=0, visible=False)

        # Flag to track if scan task should be visible
        scan_task_visible = False

        def update_discovery_description(ip: str):
            # Just show the count, ports are shown in the host section
            total = sum(len(p) for p in discovered_ports.values())
            desc = f"[#cba6f7]Ports Discovered [#89b4fa]({total} found)[/]"
            progress.update(discovery_task, description=desc)

        def worker():
            """Process discovered ports from the queue"""
            while not (stdin_done.is_set() and scan_queue.empty()):
                try:
                    ip, port = scan_queue.get(timeout=0.1)
                    target = f"{ip}:{port}"

                    with ui_lock:
                        scan_statuses[target] = "Scanning"

                    # Execute targeted Nmap scan on this specific port
                    result = self._process_discovered_port(
                        ip,
                        port,
                        nmap_args,
                        formatter=None,
                        export_manager=export_manager,
                    )

                    with ui_lock:
                        if result and result.hosts:
                            self._merge_results(final_result, result)
                            scan_statuses[target] = "Completed"
                        else:
                            scan_statuses[target] = "Failed"
                        progress.update(scan_task, advance=1)

                    scan_queue.task_done()
                except queue.Empty:
                    continue
                except Exception as e:
                    # We don't have logger here because it's muted, but we can use self.logger
                    # though it might be muted too.
                    self.logger.error(f"Error scanning {target}: {e}")
                    with ui_lock:
                        if "target" in locals() and target in scan_statuses:
                            scan_statuses[target] = "Failed"
                    scan_queue.task_done()

            self.logger.debug(f"Worker {threading.current_thread().name} finished")

        def stdin_reader():
            nonlocal scan_task_visible
            try:
                for line in sys.stdin:
                    line_stripped = line.strip()
                    all_stdin_lines.append(line)  # Keep original for parsing
                    if not line_stripped:
                        continue

                    # Match "Open 192.168.1.1:80"
                    single_match = re.search(
                        r"Open\s+(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):(\d+)",
                        line_stripped,
                    )
                    if single_match:
                        ip, port = single_match.groups()
                        with ui_lock:
                            if port not in discovered_ports[ip]:
                                discovered_ports[ip].append(port)
                                target = f"{ip}:{port}"
                                scan_statuses[target] = "Discovered"
                                scan_queue.put((ip, port))
                                progress.update(discovery_task, advance=1)
                                # Make scan task visible on first discovered port
                                if not scan_task_visible:
                                    progress.update(scan_task, visible=True)
                                    scan_task_visible = True
                                progress.update(
                                    scan_task, total=progress.tasks[scan_task].total + 1
                                )
                                update_discovery_description(ip)
                        continue

                    # Match "192.168.1.1 -> [80, 443]"
                    multi_match = re.search(
                        r"(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\s+->\s+\[([\d,\s]+)\]",
                        line_stripped,
                    )
                    if multi_match:
                        ip, ports_str = multi_match.groups()
                        ports = [p.strip() for p in ports_str.replace(",", " ").split()]
                        for port in ports:
                            if port:
                                with ui_lock:
                                    if port not in discovered_ports[ip]:
                                        discovered_ports[ip].append(port)
                                        target = f"{ip}:{port}"
                                        scan_statuses[target] = "Discovered"
                                        scan_queue.put((ip, port))
                                        progress.update(discovery_task, advance=1)
                                        # Make scan task visible on first discovered port
                                        if not scan_task_visible:
                                            progress.update(scan_task, visible=True)
                                            scan_task_visible = True
                                        progress.update(
                                            scan_task,
                                            total=progress.tasks[scan_task].total + 1,
                                        )
                                        update_discovery_description(ip)
            finally:
                stdin_done.set()

        # Start stdin reader thread
        reader_thread = threading.Thread(target=stdin_reader, daemon=True)
        reader_thread.start()

        # Start worker threads for Nmap scanning
        worker_threads = []
        for i in range(num_workers):
            t = threading.Thread(target=worker, daemon=True, name=f"NmapWorker-{i}")
            t.start()
            worker_threads.append(t)

        with Live(
            formatter.format_live_status(
                discovered_ports, scan_statuses, progress, stdin_done.is_set()
            ),
            console=formatter.console,
            refresh_per_second=4,
        ) as live:
            try:
                # Keep updating while discovery is ongoing OR workers are still active
                while reader_thread.is_alive() or any(
                    t.is_alive() for t in worker_threads
                ):
                    with ui_lock:
                        live.update(
                            formatter.format_live_status(
                                discovered_ports,
                                scan_statuses,
                                progress,
                                stdin_done.is_set(),
                            )
                        )
                    time.sleep(0.1)

                # Show final update with all scans complete
                with ui_lock:
                    live.update(
                        formatter.format_live_status(
                            discovered_ports, scan_statuses, progress, True
                        )
                    )
                time.sleep(0.5)  # Brief pause to show final state
            except KeyboardInterrupt:
                pass
            finally:
                unmute_logger()

        # All workers should be done at this point
        for t in worker_threads:
            t.join(timeout=0.1)

        # Return merged results if we have any
        with ui_lock:
            if final_result.hosts:
                # Display final summary (export already handled per-port via export_port_scan)
                formatter.format_interactive_summary(final_result)
                return final_result

            # Fallback: Create basic result from discovered ports
            if discovered_ports:
                from deluge.core.models import HostInfo, PortInfo

                hosts = []
                for ip, ports in discovered_ports.items():
                    port_infos = [
                        PortInfo(portid=int(p), protocol="tcp", state="open")
                        for p in ports
                    ]
                    hosts.append(HostInfo(address=ip, status="up", ports=port_infos))

                final_result = ScanResult(
                    nmap_version="Interactive (Fallback)",
                    args=" ".join(nmap_args),
                    start_time=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                    hosts=hosts,
                )
                formatter.format_interactive_summary(final_result)
                return final_result

            return None

    def _merge_results(self, target: ScanResult, source: ScanResult):
        """Merges a new ScanResult into the consolidated target."""
        for source_host in source.hosts:
            # Find if host already exists in target
            existing_host = next(
                (h for h in target.hosts if h.address == source_host.address), None
            )
            if existing_host:
                # Merge ports
                for source_port in source_host.ports:
                    if not any(
                        p.portid == source_port.portid
                        and p.protocol == source_port.protocol
                        for p in existing_host.ports
                    ):
                        existing_host.ports.append(source_port)
                # Merge OS matches
                for os_match in source_host.os_matches:
                    if os_match not in existing_host.os_matches:
                        existing_host.os_matches.append(os_match)
                # Merge hostnames
                for hostname in source_host.hostnames:
                    if hostname not in existing_host.hostnames:
                        existing_host.hostnames.append(hostname)
            else:
                target.hosts.append(source_host)

    def _process_discovered_port(
        self,
        ip: str,
        port: str,
        nmap_args: List[str],
        formatter: Optional["NmapFormatter"] = None,
        export_manager: Optional[ExportManager] = None,
    ) -> Optional[ScanResult]:
        """Triggers a targeted nmap scan for a specific IP and port."""
        # Filter out any existing -p flags and the stdin indicator '-' from nmap_args
        filtered_args = []
        skip_next = False
        for arg in nmap_args:
            if skip_next:
                skip_next = False
                continue
            if arg == "-p":
                skip_next = True
                continue
            if arg.startswith("-p"):
                continue
            if arg == "-":
                continue
            filtered_args.append(arg)

        target_args = [ip, "-p", port] + filtered_args

        # Run nmap and get result (quietly)
        # We use run_nmap which automatically generates a temp XML file and parses it.
        # This ensures we get rich data even if stdout parsing has gaps.

        # If export_manager is provided, we need to capture the XML content.
        # We'll use a temp file for this.
        temp_xml_path = None
        if export_manager:
            with tempfile.NamedTemporaryFile(delete=False, suffix=".xml") as tmp:
                temp_xml_path = tmp.name

        result = self.run_nmap(target_args, output_file=temp_xml_path, quiet=True)

        # Export individual scan if export manager is provided
        if export_manager and result:
            try:
                xml_content = None
                if temp_xml_path and os.path.exists(temp_xml_path):
                    with open(temp_xml_path, "r", encoding="utf-8") as f:
                        xml_content = f.read()

                # If nmap failed (e.g. not installed), we might not have XML content
                # but we still want to export what we have if possible.
                # For now, we only export if we have XML content.
                if xml_content:
                    # Determine protocol (default to tcp)
                    protocol = "tcp"
                    if result.hosts and result.hosts[0].ports:
                        protocol = result.hosts[0].ports[0].protocol

                    export_manager.export_port_scan(
                        ip, int(port), protocol, xml_content
                    )
                else:
                    # Fallback: create a minimal XML if nmap failed but we want to export
                    # This is optional based on requirements, but let's stick to real nmap output.
                    pass
            except Exception as e:
                logger.error(f"Failed to export port scan: {e}")
            finally:
                if temp_xml_path and os.path.exists(temp_xml_path):
                    os.remove(temp_xml_path)

        if not result or not result.hosts:
            # Create a dummy result for the summary if nmap failed/not found
            # This ensures the summary table shows something even if nmap isn't installed
            from deluge.core.models import HostInfo, PortInfo

            dummy_host = HostInfo(
                address=ip,
                status="unknown",
                ports=[PortInfo(portid=int(port), protocol="tcp", state="open")],
            )
            if not result:
                result = ScanResult(
                    nmap_version="N/A",
                    args=" ".join(target_args),
                    start_time=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                    hosts=[dummy_host],
                )
            else:
                result.hosts.append(dummy_host)

        # Display the results if formatter is provided
        if formatter:
            for host in result.hosts:
                formatter.format_host(host)

        return result
